#!/bin/bash

function build_auth_server() {
    /root/.cargo/bin/cargo build -q --release --manifest-path /opt/subauth/Cargo.toml
    chown -R subauth: /opt/subauth
}

function install_auth_server() {
    hostname=$(grep -m1 "server_name" /etc/nginx/sites-enabled/default | awk '{print $2}' | sed 's/;//g')

    cat > /opt/subauth/Cargo.toml << TOML
[package]
name = "subauth"
version = "0.1.0"
edition = "2021"

[dependencies]
htpasswd-verify = "0.3.0"
josekit = "0.10.3"
serde = "1.0.219"
serde_cbor = "0.11.2"
tiny_http = "0.12.0"
fastcache = "0.1.7"
chrono = { version = "0.4.41", features = ["serde"] }
serde_json = "1.0.141"
once_cell = "1.21.3"

TOML

    cat > /opt/subauth/src/main.rs << MAIN
use chrono::{DateTime, Local, TimeDelta, Utc};
use fastcache::Cache;
use htpasswd_verify::Htpasswd;
use josekit::jwe;
use josekit::jwe::{JweDecrypter, JweEncrypter, JweHeader, A256GCMKW};
use once_cell::unsync::Lazy;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::rc::Rc;
use std::time::Duration;
use tiny_http::{Header, Method, Request, Response, ResponseBox, Server, StatusCode};

const BINDING: &str = "127.0.0.1:8888";
const COOKIE_KEY: &str = "subdomain_auth=";
const COOKIE_DOMAIN: &str = "$hostname";
const COOKIE_DURATION: TimeDelta = TimeDelta::days(15);
const REFRESH_AFTER: TimeDelta = TimeDelta::days(1);

struct JWEScheme<E: JweEncrypter, D: JweDecrypter> {
    encrypter: E,
    decrypter: D,
    header: JweHeader,
}

#[derive(Serialize, Deserialize)]
struct Auth {
    username: String,
    password: String,
}

#[derive(Serialize, Deserialize)]
struct Claim {
    #[serde(with = "chrono::serde::ts_seconds")]
    issue: DateTime<Utc>,
    auth: Auth,
}

struct RequestHeaders<'a> {
    x_auth_path: String,
    x_default_auth_path: String,
    all: HashMap<&'a str, &'a str>,
}

#[derive(Debug)]
enum ValidationFailure {
    Internal,
    BadHeader,
    Bad,
    Unauthorized,
    Forbidden,
    Method,
}

fn main() {
    let server = Server::http(BINDING).expect("Could not start server");
    let secret = fs::read(".secret").expect("Could not read secrets");

    let jwe_scheme = JWEScheme {
        encrypter: A256GCMKW.encrypter_from_bytes(&secret).unwrap(),
        decrypter: A256GCMKW.decrypter_from_bytes(&secret).unwrap(),
        header: {
            let mut header = JweHeader::new();
            header.set_token_type("JWT");
            header.set_algorithm("A256KW");
            header.set_content_encryption("A256GCM");
            header
        },
    };

    for mut request in server.incoming_requests() {
        let validation_result = match request.method() {
            Method::Get => handle_get(&request, &jwe_scheme),
            Method::Post => handle_post(&mut request, &jwe_scheme),
            _ => Err(ValidationFailure::Method),
        };

        let response = match validation_result {
            Ok(response) => response,
            Err(ValidationFailure::Internal) => Response::empty(StatusCode(500)).boxed(),
            Err(ValidationFailure::BadHeader) => Response::empty(StatusCode(428)).boxed(),
            Err(ValidationFailure::Bad) => Response::empty(StatusCode(400)).boxed(),
            Err(ValidationFailure::Unauthorized) => Response::empty(StatusCode(401)).boxed(),
            Err(ValidationFailure::Forbidden) => Response::empty(StatusCode(403)).boxed(),
            Err(ValidationFailure::Method) => {
                let mut response = Response::empty(StatusCode(405));
                response.add_header(Header::from_bytes("Allow", "GET, POST").unwrap());
                response.boxed()
            }
        };

        let _ = request.respond(response);
    }
}

fn get_headers(request: &Request) -> Result<RequestHeaders, ValidationFailure> {
    let mut headers = HashMap::new();
    for header in request.headers() {
        headers
            .entry(header.field.as_str().as_str())
            .or_insert(header.value.as_str());
    }

    let x_auth_path = headers
        .remove("X-Auth-Path")
        .ok_or(ValidationFailure::BadHeader)?
        .to_string();
    let x_default_auth_path = headers
        .remove("X-Default-Auth-Path")
        .ok_or(ValidationFailure::BadHeader)?
        .to_string();

    Ok(RequestHeaders {
        x_auth_path,
        x_default_auth_path,
        all: headers,
    })
}

const HTPASSWD_CACHE: Lazy<Cache<String, Rc<Htpasswd>>> =
    Lazy::new(|| Cache::new(10, Duration::from_secs(60)));

fn get_htpasswd(x_auth_path: String) -> Result<Rc<Htpasswd<'static>>, ValidationFailure> {
    match HTPASSWD_CACHE.get(&x_auth_path) {
        Some(entry) => Ok(Rc::clone(&entry)),
        None => {
            let path = PathBuf::from(&x_auth_path);
            let data = fs::read_to_string(path).map_err(|_| ValidationFailure::BadHeader)?;
            let htpasswd = Rc::new(Htpasswd::new_owned(&data));
            HTPASSWD_CACHE.insert(x_auth_path, Rc::clone(&htpasswd));
            Ok(htpasswd)
        }
    }
}

fn handle_get<E: JweEncrypter, D: JweDecrypter>(
    request: &Request,
    jwe_scheme: &JWEScheme<E, D>,
) -> Result<ResponseBox, ValidationFailure> {
    // Extract headers
    let headers = get_headers(&request)?;
    let http_cookie = headers
        .all
        .get("Cookie")
        .ok_or(ValidationFailure::Unauthorized)?;

    // Find JWE
    let jwe = http_cookie.split(',').find_map(|cookie| {
        cookie
            .trim()
            .strip_prefix(COOKIE_KEY)
            .map(|s| s.to_string())
    });

    verify_jwe(jwe_scheme, jwe, headers)
}

fn handle_post<E: JweEncrypter, D: JweDecrypter>(
    request: &mut Request,
    jwe_scheme: &JWEScheme<E, D>,
) -> Result<ResponseBox, ValidationFailure> {
    let headers = get_headers(&request)?;
    if headers.all.get("Content-Type") != Some(&"application/json") {
        return Err(ValidationFailure::Bad);
    }

    let x_auth_path = headers.x_auth_path;
    let x_default_auth_path = headers.x_default_auth_path;

    // Parse JSON body
    let body_reader = request.as_reader();
    let auth: Auth = serde_json::from_reader(body_reader).map_err(|_| ValidationFailure::Bad)?;

    // Check authority
    let forbidden = match verify_auth(&auth, x_auth_path, x_default_auth_path) {
        Ok(()) => false,
        Err(ValidationFailure::Forbidden) => true,
        Err(err) => return Err(err),
    };
    issue_jwe(
        jwe_scheme,
        Claim {
            issue: Local::now().to_utc(),
            auth,
        },
        forbidden,
    )
}

fn verify_auth(
    auth: &Auth,
    x_auth_path: String,
    x_default_auth_path: String,
) -> Result<(), ValidationFailure> {
    let htpasswd = get_htpasswd(x_auth_path)?;
    if !htpasswd.check(&auth.username, &auth.password) {
        let default_htpasswd = get_htpasswd(x_default_auth_path)?;
        if !default_htpasswd.check(&auth.username, &auth.password) {
            return Err(ValidationFailure::Unauthorized);
        };
        return Err(ValidationFailure::Forbidden);
    }
    Ok(())
}

fn verify_jwe<E: JweEncrypter, D: JweDecrypter>(
    scheme: &JWEScheme<E, D>,
    raw: Option<String>,
    headers: RequestHeaders,
) -> Result<ResponseBox, ValidationFailure> {
    // Retrieve JWE
    let content = raw.ok_or(ValidationFailure::Unauthorized)?;
    let (payload, _) = jwe::deserialize_compact(&content, &scheme.decrypter)
        .map_err(|_| ValidationFailure::Unauthorized)?;
    let mut claim =
        serde_cbor::from_slice::<Claim>(&payload).map_err(|_| ValidationFailure::Unauthorized)?;

    // Expiry check
    let now = Local::now().to_utc();
    if claim.issue + COOKIE_DURATION < now {
        return Err(ValidationFailure::Unauthorized);
    }

    verify_auth(
        &claim.auth,
        headers.x_auth_path,
        headers.x_default_auth_path,
    )?;

    // JWE valid
    if now - claim.issue > REFRESH_AFTER {
        claim.issue = now;
        Ok(issue_jwe(&scheme, claim, false)?)
    } else {
        let mut response = Response::empty(StatusCode(204));
        response.add_header(
            Header::from_bytes("X-Remote-User", claim.auth.username)
                .map_err(|_| ValidationFailure::Internal)?,
        );
        Ok(response.boxed())
    }
}

fn issue_jwe<E: JweEncrypter, D: JweDecrypter>(
    scheme: &JWEScheme<E, D>,
    claim: Claim,
    forbidden: bool,
) -> Result<ResponseBox, ValidationFailure> {
    let payload = serde_cbor::to_vec(&claim)
        .map_err(|_| ValidationFailure::Internal)?;
    let new_jwe = jwe::serialize_compact(&payload, &scheme.header, &scheme.encrypter)
        .map_err(|_| ValidationFailure::Internal)?;

    let expiry = claim.issue + COOKIE_DURATION;
    let cookie = format!(
        "{COOKIE_KEY}{}; Domain={}; Expires={}; HttpOnly; Path=/; SameSite=Lax; Secure",
        new_jwe,
        COOKIE_DOMAIN,
        expiry.format("%a, %d %b %Y %H:%M:%S GMT")
    );

    let status = if forbidden { 403 } else { 204 };
    let mut response = Response::empty(StatusCode(status));
    response.add_header(
        Header::from_bytes("Set-Cookie", cookie)
            .map_err(|_| ValidationFailure::Internal)?,
    );
    response.add_header(
        Header::from_bytes("X-Remote-User", claim.auth.username)
            .map_err(|_| ValidationFailure::Internal)?,
    );
    Ok(response.boxed())
}

MAIN
}
